<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subtitle Annotation Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: #fff;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .subtitle-text {
            color: #7f8c8d;
            font-size: 14px;
        }

        /* File Upload Section */
        .upload-section {
            background-color: #fff;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            margin-bottom: 20px;
        }

        .upload-zone {
            border: 3px dashed #3498db;
            border-radius: 8px;
            padding: 40px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-zone:hover {
            background-color: #ecf0f1;
            border-color: #2980b9;
        }

        .upload-zone.dragover {
            background-color: #d5e8f7;
            border-color: #2980b9;
        }

        #fileInput {
            display: none;
        }

        .btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            background-color: #2980b9;
        }

        .btn-secondary {
            background-color: #95a5a6;
        }

        .btn-secondary:hover {
            background-color: #7f8c8d;
        }

        .btn-success {
            background-color: #27ae60;
        }

        .btn-success:hover {
            background-color: #229954;
        }

        .btn-danger {
            background-color: #e74c3c;
        }

        .btn-danger:hover {
            background-color: #c0392b;
        }

        /* Character Management */
        .character-management {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: none;
        }

        .character-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .character-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 4px;
            gap: 8px;
        }

        .character-item.special {
            background-color: #d5d8db;
            font-style: italic;
        }

        .character-item input[type="checkbox"] {
            margin-right: 10px;
        }

        .character-name {
            flex: 1;
        }

        .character-count {
            color: #7f8c8d;
            font-size: 12px;
            min-width: 40px;
            text-align: right;
        }

        .button-container {
            display: flex;
            flex-direction: column;
            gap: 3px;
            margin-left: auto;
        }

        .button-row {
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .reorder-btn {
            background-color: #95a5a6;
            color: white;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            line-height: 1;
        }

        .reorder-btn:hover {
            background-color: #7f8c8d;
        }

        .reorder-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .action-btn {
            background-color: transparent;
            border: none;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 4px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .action-btn:hover {
            opacity: 1;
        }

        .action-btn.edit {
            color: #3498db;
        }

        .action-btn.delete {
            color: #e74c3c;
        }

        .add-character {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .add-character input {
            flex: 1;
            padding: 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
        }

        /* Annotation Workspace */
        .annotation-workspace {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }

        .progress-bar {
            background-color: #ecf0f1;
            height: 30px;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-fill {
            background-color: #27ae60;
            height: 100%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .keyboard-hints {
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .keyboard-hints h3 {
            margin-bottom: 10px;
            color: #856404;
        }

        .shortcuts {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .shortcut {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .key {
            background-color: #495057;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }

        .subtitle-list {
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }

        .subtitle-entry {
            display: grid;
            grid-template-columns: 80px 180px 1fr 200px 40px;
            gap: 15px;
            padding: 15px;
            border-bottom: 1px solid #dee2e6;
            align-items: center;
            transition: background-color 0.2s ease;
        }

        .subtitle-entry:hover {
            background-color: #f8f9fa;
        }

        .subtitle-entry.annotated {
            background-color: #d4edda;
        }

        .subtitle-entry.prefilled {
            background-color: #cce5ff;
        }

        .subtitle-entry.active {
            border-left: 5px solid #f39c12;
            background-color: #fff3cd;
        }

        .entry-index {
            color: #6c757d;
            font-weight: bold;
        }

        .entry-timestamp {
            color: #495057;
            font-family: monospace;
            font-size: 12px;
        }

        .entry-text {
            color: #212529;
        }

        .entry-character select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }

        .entry-status {
            text-align: center;
        }

        .status-icon {
            font-size: 20px;
        }

        .export-section {
            margin-top: 20px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
        }

        .modal-content h3 {
            margin-bottom: 20px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Subtitle Annotation Tool</h1>
            <p class="subtitle-text">Tag subtitle lines with character names for analysis and export</p>
            <p id="currentFile" class="subtitle-text" style="display: none; margin-top: 5px; font-weight: 600; color: #2c3e50;">üìÑ <span id="filename"></span></p>
        </header>

        <!-- File Upload Section -->
        <div class="upload-section" id="uploadSection">
            <div class="upload-zone" id="uploadZone">
                <h2>üìÅ Load Subtitle File</h2>
                <p>Drag and drop a .srt or .ass file here, or click to browse</p>
                <input type="file" id="fileInput" accept=".srt,.ass">
                <button class="btn" onclick="document.getElementById('fileInput').click()">Choose File</button>
            </div>
        </div>

        <!-- Character Management Section -->
        <div class="character-management" id="characterManagement">
            <h2>Character Management</h2>
            <p id="characterInfo">Review and manage the character list</p>
            <p style="font-size: 12px; color: #7f8c8d; margin-top: 5px;">üí° Tip: Use <kbd style="padding: 2px 5px; background: #f5f5f5; border: 1px solid #ccc; border-radius: 3px;">Ctrl+Z</kbd> to undo and <kbd style="padding: 2px 5px; background: #f5f5f5; border: 1px solid #ccc; border-radius: 3px;">Ctrl+Y</kbd> to redo changes</p>

            <div style="margin: 15px 0; display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="btn" id="mergeBtn" onclick="showMergeModal()" disabled>Merge Characters</button>
                <button class="btn" onclick="sortCharactersByFrequency()">Sort by Frequency</button>
                <button class="btn" onclick="exportCharacterList()">Export Character List</button>
                <button class="btn" onclick="document.getElementById('importCharacterFile').click()">Import Character List</button>
                <button class="btn btn-danger" onclick="clearGlobalCharacterList()">Clear Global List</button>
                <input type="file" id="importCharacterFile" accept=".json" style="display: none;" onchange="importCharacterList(event)">
            </div>

            <div id="characterList" class="character-list"></div>

            <div class="add-character">
                <input type="text" id="newCharacterInput" placeholder="Add new character...">
                <button class="btn" onclick="addNewCharacter()">Add</button>
            </div>

            <div style="margin-top: 20px; text-align: center;">
                <button class="btn btn-success" onclick="startAnnotating()">Start Annotating</button>
                <button class="btn btn-secondary" onclick="resetApp()">Cancel</button>
            </div>
        </div>

        <!-- Annotation Workspace -->
        <div class="annotation-workspace" id="annotationWorkspace">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0 / 0 annotated</div>
            </div>

            <div style="margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 4px; display: flex; align-items: center; gap: 10px;">
                <label for="characterFilter" style="font-weight: 600;">Filter:</label>
                <select id="characterFilter" onchange="handleFilterChange()" style="padding: 6px 10px; border: 1px solid #ced4da; border-radius: 4px; flex: 1; max-width: 300px;">
                    <option value="all">All lines</option>
                    <option value="unannotated">Unannotated only</option>
                </select>
                <span id="filterStats" style="color: #6c757d; font-size: 14px;"></span>
            </div>

            <div class="keyboard-hints">
                <h3>Keyboard Shortcuts</h3>
                <p style="margin-bottom: 10px; font-size: 14px;">The line with the <strong>orange border</strong> is the active target for keyboard shortcuts.</p>
                <div class="shortcuts" id="shortcutHints"></div>
            </div>

            <div class="subtitle-list" id="subtitleList"></div>

            <div class="export-section">
                <div>
                    <strong id="exportStats">Ready to export</strong>
                </div>
                <div>
                    <button class="btn" onclick="editCharacters()">Edit Characters</button>
                    <button class="btn btn-success" onclick="showExportModal()">Export</button>
                    <button class="btn btn-secondary" onclick="resetApp()">New File</button>
                    <button class="btn btn-danger" onclick="clearSession()">Clear Session</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <h3>Export Annotations</h3>

            <p><strong>Format:</strong></p>
            <div style="margin: 10px 0 20px 0;">
                <label>
                    <input type="radio" name="exportFormat" value="json" checked> JSON (for LLM consumption)
                </label>
                <br>
                <label>
                    <input type="radio" name="exportFormat" value="csv"> CSV (for spreadsheet analysis)
                </label>
            </div>

            <p><strong>Content:</strong></p>
            <div style="margin: 10px 0 20px 0;">
                <label>
                    <input type="radio" name="exportType" value="annotated" checked> Only annotated lines
                </label>
                <br>
                <label>
                    <input type="radio" name="exportType" value="all"> All lines (including unannotated)
                </label>
            </div>

            <div class="modal-buttons">
                <button class="btn btn-secondary" onclick="closeExportModal()">Cancel</button>
                <button class="btn btn-success" onclick="handleExport()">Export</button>
            </div>
        </div>
    </div>

    <!-- Merge Characters Modal -->
    <div class="modal" id="mergeModal">
        <div class="modal-content">
            <h3>Merge Characters</h3>
            <p>Select the canonical name for the merged character:</p>

            <div id="mergeOptions" style="margin: 20px 0;">
                <!-- Radio buttons will be populated dynamically -->
            </div>

            <div style="margin: 20px 0;">
                <label>
                    <input type="radio" name="mergeCanonical" value="custom"> Custom name:
                </label>
                <input type="text" id="customCanonicalName" style="margin-left: 10px; padding: 8px; width: 250px;">
            </div>

            <p id="mergePreview" style="margin: 15px 0; padding: 10px; background-color: #f0f0f0; border-radius: 4px; font-size: 14px;"></p>

            <div class="modal-buttons">
                <button class="btn btn-secondary" onclick="closeMergeModal()">Cancel</button>
                <button class="btn btn-success" onclick="confirmMerge()">Merge</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let appState = {
            filename: '',
            subtitles: [],
            characters: [],
            topCharacters: []
        };

        // UI state for expandable alias sections (not persisted)
        let aliasExpandedState = {};

        // Filter state for annotation workspace
        let currentFilter = 'all'; // 'all', 'unannotated', or character name

        // Undo/Redo stacks
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STATES = 50; // Limit stack size to prevent memory issues

        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            setupFileUpload();
            checkForSavedSession();
        });

        function setupFileUpload() {
            const uploadZone = document.getElementById('uploadZone');
            const fileInput = document.getElementById('fileInput');

            uploadZone.addEventListener('click', () => fileInput.click());

            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('dragover');
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file) handleFileSelect(file);
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) handleFileSelect(file);
            });
        }

        function handleFileSelect(file) {
            if (!file.name.match(/\.(srt|ass)$/i)) {
                alert('Please select a .srt or .ass file');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                const extension = file.name.split('.').pop().toLowerCase();

                appState.filename = file.name;
                updateFilenameDisplay();

                // Reset filter state when loading a new file
                currentFilter = 'all';

                // Clear undo/redo stacks when loading a new file
                undoStack = [];
                redoStack = [];

                // Check for saved session
                const savedSessionKey = `subtitle-annotation-${file.name}`;
                const savedSession = localStorage.getItem(savedSessionKey);

                if (savedSession) {
                    const loadSaved = confirm(`Found a saved session for "${file.name}". Would you like to restore your progress?`);
                    if (loadSaved) {
                        appState = JSON.parse(savedSession);
                        updateFilenameDisplay();
                        showCharacterManagement();
                        return;
                    }
                }

                // No saved session or user declined - parse fresh
                if (extension === 'srt') {
                    appState.subtitles = parseSRT(content);
                } else if (extension === 'ass') {
                    appState.subtitles = parseASS(content);
                }

                extractCharacters();
                showCharacterManagement();
            };
            reader.readAsText(file);
        }

        function parseSRT(content) {
            const subtitles = [];
            const entries = content.split(/\n\s*\n/).filter(e => e.trim());

            entries.forEach(entry => {
                const lines = entry.split('\n');
                if (lines.length < 3) return;

                const index = parseInt(lines[0]);
                const timestamp = lines[1];
                const text = lines.slice(2).join('\n');

                // Extract character name from Japanese markers ÔºàÔºâ
                // Match anywhere in text, not just at start (handles „ÄàÔºàNameÔºâ...„Äâ format)
                const characterMatch = text.match(/\uff08([^\uff09]+)\uff09/);
                let character = null;
                let isPrefilled = false;

                if (characterMatch) {
                    character = characterMatch[1];
                    isPrefilled = true;
                }

                subtitles.push({
                    index,
                    timestamp,
                    text,
                    character,
                    isPrefilled
                });
            });

            return subtitles;
        }

        function parseASS(content) {
            const subtitles = [];
            const lines = content.split('\n');
            let inEvents = false;
            let index = 0;

            for (let line of lines) {
                if (line.includes('[Events]')) {
                    inEvents = true;
                    continue;
                }

                if (inEvents && line.startsWith('Dialogue:')) {
                    // Dialogue: Layer,Start,End,Style,Name,MarginL,MarginR,MarginV,Effect,Text
                    const parts = line.substring(9).split(',');

                    if (parts.length >= 10) {
                        const start = parts[1].trim();
                        const end = parts[2].trim();
                        const name = parts[4].trim();
                        const text = parts.slice(9).join(',').replace(/\\N/g, ' ').trim();

                        let character = null;
                        let isPrefilled = false;

                        // Try to get character from Name field first (English ASS)
                        if (name && name !== '' && !isNonCharacterName(name)) {
                            character = name;
                            isPrefilled = true;
                        } else {
                            // Try to extract from text markers (Japanese ASS)
                            // Match anywhere in text, not just at start (handles „ÄàÔºàNameÔºâ...„Äâ format)
                            const characterMatch = text.match(/\uff08([^\uff09]+)\uff09/);
                            if (characterMatch) {
                                character = characterMatch[1];
                                isPrefilled = true;
                            }
                        }

                        subtitles.push({
                            index: index++,
                            timestamp: `${start} --> ${end}`,
                            text,
                            character,
                            isPrefilled
                        });
                    }
                }
            }

            return subtitles;
        }

        function isNonCharacterName(name) {
            // Filter out common non-character entries
            const nonCharacterPatterns = [
                /^signs/i,
                /^default/i,
                /^style/i,
                'Ë∂≥Èü≥', '„ÉÅ„É£„Ç§„É†', '„Éâ„Ç¢„ÅåÈñã„Åè', '„Ç∑„É£„ÉÉ„Çø„Éº„ÇíÊäº„Åô',
                '‚ô™', '„Éª', '„Äà', '„Äâ'
            ];

            return nonCharacterPatterns.some(pattern => {
                if (typeof pattern === 'string') {
                    return name.includes(pattern);
                } else {
                    return pattern.test(name);
                }
            });
        }

        function extractCharacters() {
            const characterCounts = {};

            // Count characters from all subtitles
            appState.subtitles.forEach(sub => {
                if (sub.character && !isNonCharacterName(sub.character)) {
                    characterCounts[sub.character] = (characterCounts[sub.character] || 0) + 1;
                }
            });

            // Check for global character list in localStorage
            const globalListStr = localStorage.getItem('global-character-list');
            let characters = [];
            let useGlobalList = false;

            if (globalListStr) {
                try {
                    const globalList = JSON.parse(globalListStr);
                    const charCount = globalList.filter(c => c.name !== '(Other)').length;

                    // Ask user if they want to use the global list
                    const choice = confirm(
                        `Found a saved global character list with ${charCount} characters.\n\n` +
                        `Click OK to use this list (maintains order across files).\n` +
                        `Click Cancel to use only characters from this file.`
                    );

                    if (choice) {
                        useGlobalList = true;

                        // Build alias-to-canonical mapping
                        const aliasMap = {};
                        globalList.forEach(char => {
                            if (char.aliases && char.aliases.length > 0) {
                                char.aliases.forEach(alias => {
                                    aliasMap[alias] = char.canonicalName || char.name;
                                });
                            }
                        });

                        // Map detected character names through aliases and update subtitles
                        const mappedCounts = {};
                        Object.keys(characterCounts).forEach(detectedName => {
                            const canonicalName = aliasMap[detectedName] || detectedName;
                            mappedCounts[canonicalName] = (mappedCounts[canonicalName] || 0) + characterCounts[detectedName];

                            // Update subtitles to use canonical names if this is an alias
                            if (aliasMap[detectedName]) {
                                appState.subtitles.forEach(sub => {
                                    if (sub.character === detectedName) {
                                        sub.character = canonicalName;
                                    }
                                });
                            }
                        });

                        // Use global list order, but update counts from mapped counts
                        characters = globalList.map(char => ({
                            name: char.name,
                            canonicalName: char.canonicalName || char.name,
                            aliases: char.aliases || [],
                            count: mappedCounts[char.name] || 0,
                            isAlias: char.isAlias || false
                        }));

                        // Add any new characters from current file not in global list (and not aliases)
                        Object.keys(characterCounts).forEach(name => {
                            if (!characters.some(c => c.name === name) && !aliasMap[name]) {
                                characters.push({
                                    name,
                                    canonicalName: name,
                                    aliases: [],
                                    count: characterCounts[name],
                                    isAlias: false
                                });
                            }
                        });
                    }
                } catch (err) {
                    console.error('Error loading global character list:', err);
                }
            }

            if (!useGlobalList) {
                // No global list or user declined - sort by frequency
                characters = Object.entries(characterCounts)
                    .sort((a, b) => b[1] - a[1])
                    .map(([name, count]) => ({
                        name,
                        canonicalName: name,
                        aliases: [],
                        count,
                        isAlias: false
                    }));
            }

            // Always ensure "(Other)" is first
            const otherIndex = characters.findIndex(c => c.name === '(Other)');
            if (otherIndex === -1) {
                characters.unshift({
                    name: '(Other)',
                    canonicalName: '(Other)',
                    aliases: [],
                    count: 0,
                    isAlias: false
                });
            } else if (otherIndex !== 0) {
                const other = characters.splice(otherIndex, 1)[0];
                characters.unshift(other);
            }

            appState.characters = characters;
            updateTopCharacters();
        }

        function clearGlobalCharacterList() {
            const confirm = window.confirm(
                'Are you sure you want to clear the global character list?\n\n' +
                'This will remove the saved character order that applies to new files.\n' +
                'The current file\'s character list will not be affected.'
            );

            if (confirm) {
                localStorage.removeItem('global-character-list');
                alert('Global character list cleared.');
            }
        }

        function updateTopCharacters() {
            // Exclude "(Other)" from 1-9 hotkeys (it's always on 0)
            // Also exclude aliases (only show canonical characters)
            appState.topCharacters = appState.characters
                .filter(c => !c.isAlias && c.name !== '(Other)')
                .slice(0, 9)
                .map(c => c.name);
        }

        function showCharacterManagement() {
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('annotationWorkspace').style.display = 'none';
            document.getElementById('characterManagement').style.display = 'block';

            const totalLines = appState.subtitles.length;
            const prefilledLines = appState.subtitles.filter(s => s.isPrefilled).length;

            let infoText = `Loaded ${totalLines} subtitle entries. `;
            if (appState.characters.length > 0) {
                infoText += `Found ${appState.characters.length} characters (${prefilledLines} lines pre-annotated).`;
            } else {
                infoText += 'No characters detected. You can add them manually below.';
            }

            document.getElementById('characterInfo').textContent = infoText;
            renderCharacterList();

            // Add event delegation for checkbox changes
            const characterList = document.getElementById('characterList');
            characterList.removeEventListener('change', handleCheckboxChange); // Remove old listener if exists
            characterList.addEventListener('change', handleCheckboxChange);
        }

        function handleCheckboxChange(e) {
            if (e.target.classList.contains('char-select')) {
                updateMergeButtonState();
            }
        }

        function renderCharacterList() {
            const container = document.getElementById('characterList');

            // Force a complete DOM clear and rebuild
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }

            if (appState.characters.length === 0) {
                const emptyMsg = document.createElement('p');
                emptyMsg.style.cssText = 'grid-column: 1/-1; text-align: center; color: #6c757d;';
                emptyMsg.textContent = 'No characters found. Add characters using the input below.';
                container.appendChild(emptyMsg);
                return;
            }

            // Filter out alias entries for now (we'll show them differently later)
            const mainCharacters = appState.characters.filter(c => !c.isAlias);

            mainCharacters.forEach((char, idx) => {
                const actualIdx = appState.characters.indexOf(char);
                const item = document.createElement('div');
                item.className = 'character-item';

                const isOther = char.name === '(Other)';
                const isFirst = actualIdx === 0;
                const isLast = actualIdx === appState.characters.length - 1;

                // Mark "(Other)" as special with darker background
                if (isOther) {
                    item.classList.add('special');
                }

                // Disable both arrows for "(Other)" since it's locked to first position
                // Also disable left arrow for first real character (can't move left past "(Other)")
                const disableLeft = actualIdx <= 1 || isOther;
                const disableRight = isLast || isOther;

                item.innerHTML = `
                    <input type="checkbox" id="char-${actualIdx}" class="char-select" data-index="${actualIdx}">
                    <div style="display: flex; flex-direction: column; flex: 1; gap: 4px;">
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <label for="char-${actualIdx}" class="character-name">${char.name}</label>
                            <span class="character-count">(${char.count})</span>
                        </div>
                    </div>
                    <div class="button-container">
                        <div class="button-row">
                            <button class="reorder-btn" onclick="moveCharacter(${actualIdx}, -1)" ${disableLeft ? 'disabled' : ''} title="Move left">‚óÄ</button>
                            <button class="reorder-btn" onclick="moveCharacter(${actualIdx}, 1)" ${disableRight ? 'disabled' : ''} title="Move right">‚ñ∂</button>
                        </div>
                        <div class="button-row">
                            <button class="action-btn edit" onclick="editCharacterName(${actualIdx})" title="Edit name" ${isOther ? 'disabled style="opacity: 0.2; cursor: not-allowed;"' : ''}>‚úèÔ∏è</button>
                            <button class="action-btn delete" onclick="deleteCharacter(${actualIdx})" title="Delete character" ${isOther ? 'disabled style="opacity: 0.2; cursor: not-allowed;"' : ''}>üóëÔ∏è</button>
                        </div>
                    </div>
                `;

                // Show aliases if they exist with individual unmerge buttons
                if (char.aliases && char.aliases.length > 0) {
                    // Determine if this section should be expanded
                    const aliasKey = `char-${actualIdx}`;

                    // Initialize expanded state if not set (default to collapsed)
                    if (aliasExpandedState[aliasKey] === undefined) {
                        aliasExpandedState[aliasKey] = false;
                    }
                    const isExpanded = aliasExpandedState[aliasKey];

                    // Create wrapper for alias section
                    const aliasWrapper = document.createElement('div');
                    aliasWrapper.style.cssText = 'margin-top: 4px;';

                    // Create toggle button
                    const toggleBtn = document.createElement('button');
                    toggleBtn.style.cssText = 'background: none; border: none; cursor: pointer; padding: 2px 4px; color: #6c757d; font-size: 12px; font-style: italic;';
                    toggleBtn.innerHTML = `${isExpanded ? '‚ñº' : '‚ñ∂'} Aliases (${char.aliases.length})`;
                    toggleBtn.onclick = () => toggleAliasExpansion(aliasKey);
                    aliasWrapper.appendChild(toggleBtn);

                    // Create alias content section
                    const aliasSection = document.createElement('div');
                    aliasSection.id = `alias-section-${aliasKey}`;
                    aliasSection.style.cssText = `font-size: 12px; font-style: italic; color: #6c757d; display: ${isExpanded ? 'flex' : 'none'}; align-items: center; gap: 6px; flex-wrap: wrap; margin-top: 4px;`;

                    char.aliases.forEach((alias, aliasIdx) => {
                        const aliasChip = document.createElement('span');
                        aliasChip.style.cssText = 'background-color: #d5d8db; padding: 2px 6px; border-radius: 3px; display: inline-flex; align-items: center; gap: 4px;';
                        aliasChip.innerHTML = `
                            ${alias}
                            <button onclick="unmergeAlias(${actualIdx}, ${aliasIdx})" style="background: none; border: none; cursor: pointer; color: #e74c3c; padding: 0; font-size: 11px;" title="Unmerge this alias">‚úñ</button>
                        `;
                        aliasSection.appendChild(aliasChip);
                    });

                    aliasWrapper.appendChild(aliasSection);

                    // Append to the left content wrapper (second child of item)
                    item.children[1].appendChild(aliasWrapper);
                }

                container.appendChild(item);
            });

            // Update merge button state
            updateMergeButtonState();
        }

        function updateMergeButtonState() {
            const selectedCheckboxes = document.querySelectorAll('.char-select:checked');
            const mergeBtn = document.getElementById('mergeBtn');

            if (mergeBtn) {
                mergeBtn.disabled = selectedCheckboxes.length < 1;
            }
        }

        function showMergeModal() {
            const selectedCheckboxes = document.querySelectorAll('.char-select:checked');
            if (selectedCheckboxes.length < 1) {
                alert('Please select at least 1 character');
                return;
            }

            // Get selected character indices
            const selectedIndices = Array.from(selectedCheckboxes).map(cb => parseInt(cb.dataset.index));
            const selectedCharacters = selectedIndices.map(idx => appState.characters[idx]);

            // Check if "(Other)" is selected
            if (selectedCharacters.some(c => c.name === '(Other)')) {
                alert('Cannot merge the "(Other)" category');
                return;
            }

            // Update modal title based on selection count
            const modalTitle = document.querySelector('#mergeModal h3');
            const isSingleCharacter = selectedCharacters.length === 1;
            modalTitle.textContent = isSingleCharacter ? 'Set Canonical Name' : 'Merge Characters';

            // Update instructional text
            const modalInstruction = document.querySelector('#mergeModal p');
            modalInstruction.textContent = isSingleCharacter
                ? 'Enter the canonical name for this character:'
                : 'Select the canonical name for the merged character:';

            // Populate merge options
            const mergeOptions = document.getElementById('mergeOptions');
            mergeOptions.innerHTML = '';

            // For single character, only show existing name if there are aliases
            // For multiple characters, show all selected characters
            if (!isSingleCharacter) {
                selectedCharacters.forEach((char, idx) => {
                    const label = document.createElement('label');
                    label.style.cssText = 'display: block; margin: 10px 0;';
                    label.innerHTML = `
                        <input type="radio" name="mergeCanonical" value="${idx}" ${idx === 0 ? 'checked' : ''}>
                        ${char.name} (${char.count} lines)
                    `;
                    mergeOptions.appendChild(label);
                });
            }

            // Reset custom name field and check the custom radio
            document.getElementById('customCanonicalName').value = '';
            if (isSingleCharacter) {
                // For single character, pre-populate with current name and select custom option
                document.getElementById('customCanonicalName').value = selectedCharacters[0].name;
                document.querySelector('input[value="custom"]').checked = true;
            }

            // Update preview
            updateMergePreview();

            // Show modal
            document.getElementById('mergeModal').classList.add('show');

            // Add event listeners for preview updates
            document.querySelectorAll('input[name="mergeCanonical"]').forEach(radio => {
                radio.addEventListener('change', updateMergePreview);
            });
            document.getElementById('customCanonicalName').addEventListener('input', updateMergePreview);
        }

        function updateMergePreview() {
            const selectedCheckboxes = document.querySelectorAll('.char-select:checked');
            const selectedIndices = Array.from(selectedCheckboxes).map(cb => parseInt(cb.dataset.index));
            const selectedCharacters = selectedIndices.map(idx => appState.characters[idx]);

            const totalLines = selectedCharacters.reduce((sum, char) => sum + char.count, 0);
            const charCount = selectedCharacters.length;

            const preview = document.getElementById('mergePreview');
            if (charCount === 1) {
                preview.textContent = `Setting canonical name for ${selectedCharacters[0].name} (${totalLines} lines)`;
            } else {
                preview.textContent = `Merging ${charCount} characters (${totalLines} total lines)`;
            }
        }

        function closeMergeModal() {
            document.getElementById('mergeModal').classList.remove('show');
        }

        function confirmMerge() {
            const selectedCheckboxes = document.querySelectorAll('.char-select:checked');
            const selectedIndices = Array.from(selectedCheckboxes).map(cb => parseInt(cb.dataset.index));
            const selectedCharacters = selectedIndices.map(idx => appState.characters[idx]);

            // Determine canonical name
            const canonicalChoice = document.querySelector('input[name="mergeCanonical"]:checked').value;
            let canonicalName;

            if (canonicalChoice === 'custom') {
                canonicalName = document.getElementById('customCanonicalName').value.trim();
                if (!canonicalName) {
                    alert('Please enter a custom canonical name');
                    return;
                }
            } else {
                canonicalName = selectedCharacters[parseInt(canonicalChoice)].name;
            }

            // Save state for undo
            saveStateForUndo();

            // Check for single-character rename vs multi-character merge
            if (selectedCharacters.length === 1) {
                // Single-character rename: set canonical name and preserve old name as alias
                const char = appState.characters[selectedIndices[0]];
                const oldName = char.name;

                // Update canonical name
                char.canonicalName = canonicalName;

                // If name changed, add old name to aliases and update everything
                if (oldName !== canonicalName) {
                    // Add old name to aliases (if not already there)
                    if (!char.aliases.includes(oldName)) {
                        char.aliases.push(oldName);
                    }

                    // Update all annotations with this character to use canonical name
                    appState.subtitles.forEach(sub => {
                        if (sub.character === oldName) {
                            sub.character = canonicalName;
                        }
                    });

                    // Update the character's display name
                    char.name = canonicalName;
                }
            } else {
                // Multi-character merge: use existing merge logic
                mergeCharacters(selectedIndices, canonicalName);
            }

            // Close modal and update UI
            closeMergeModal();
            renderCharacterList();
            updateTopCharacters();
            saveToLocalStorage();

            // Update annotation workspace if visible
            if (document.getElementById('annotationWorkspace').style.display !== 'none') {
                populateCharacterFilter();
                renderSubtitleList();
                updateProgress();
            }
        }

        function toggleAliasExpansion(aliasKey) {
            // Toggle the expanded state
            aliasExpandedState[aliasKey] = !aliasExpandedState[aliasKey];

            // Re-render to update the UI
            renderCharacterList();
        }

        function unmergeAlias(canonicalIndex, aliasIndex) {
            const canonicalChar = appState.characters[canonicalIndex];
            const aliasName = canonicalChar.aliases[aliasIndex];

            const confirmUnmerge = confirm(
                `Unmerge "${aliasName}" from "${canonicalChar.name}"?\n\n` +
                `This will create a new character entry for "${aliasName}" with 0 lines.\n` +
                `You'll need to manually reassign lines if desired.`
            );

            if (!confirmUnmerge) return;

            // Save state for undo
            saveStateForUndo();

            // Remove alias from canonical character
            canonicalChar.aliases.splice(aliasIndex, 1);

            // Create new character entry for the unmerged alias
            appState.characters.push({
                name: aliasName,
                canonicalName: aliasName,
                aliases: [],
                count: 0,
                isAlias: false
            });

            // Update UI
            updateTopCharacters();
            renderCharacterList();
            saveToLocalStorage();

            // Update annotation workspace if visible
            if (document.getElementById('annotationWorkspace').style.display !== 'none') {
                populateCharacterFilter();
                renderSubtitleList();
                updateProgress();
            }
        }

        function mergeCharacters(indices, canonicalName) {
            // Sort indices in descending order to avoid index shifting issues
            indices.sort((a, b) => b - a);

            // Find or create the canonical character
            let canonicalChar = appState.characters.find(c => c.name === canonicalName);
            let canonicalIndex;

            if (canonicalChar) {
                canonicalIndex = appState.characters.indexOf(canonicalChar);
            } else {
                // Create new canonical character
                canonicalChar = {
                    name: canonicalName,
                    canonicalName: canonicalName,
                    aliases: [],
                    count: 0,
                    isAlias: false
                };
                appState.characters.push(canonicalChar);
                canonicalIndex = appState.characters.length - 1;
            }

            // Merge all selected characters into canonical
            const aliasNames = [];
            let totalCount = canonicalChar.count;

            indices.forEach(idx => {
                const char = appState.characters[idx];
                if (char.name !== canonicalName) {
                    // Add this character as an alias
                    aliasNames.push(char.name);
                    totalCount += char.count;

                    // Also add any existing aliases
                    if (char.aliases && char.aliases.length > 0) {
                        aliasNames.push(...char.aliases);
                    }

                    // Update all annotations with this character to use canonical name
                    appState.subtitles.forEach(sub => {
                        if (sub.character === char.name) {
                            sub.character = canonicalName;
                        }
                    });
                }
            });

            // Update canonical character
            canonicalChar.aliases = [...new Set([...canonicalChar.aliases, ...aliasNames])]; // Deduplicate
            canonicalChar.count = totalCount;

            // Remove merged characters (skip the canonical if it was in the selection)
            indices.forEach(idx => {
                if (idx !== canonicalIndex) {
                    appState.characters.splice(idx, 1);
                }
            });

            // Update top characters list
            updateTopCharacters();

            // Update progress display
            if (document.getElementById('annotationWorkspace').style.display !== 'none') {
                populateCharacterFilter();
                renderSubtitleList();
                updateProgress();
            }
        }

        function addNewCharacter() {
            const input = document.getElementById('newCharacterInput');
            const name = input.value.trim();

            if (!name) {
                alert('Please enter a character name');
                return;
            }

            if (appState.characters.some(c => c.name === name)) {
                alert('Character already exists');
                return;
            }

            // Save state for undo
            saveStateForUndo();

            appState.characters.push({
                name,
                canonicalName: name,
                aliases: [],
                count: 0,
                isAlias: false
            });
            input.value = '';
            updateTopCharacters();
            renderCharacterList();
            saveToLocalStorage();
        }

        function moveCharacter(index, direction) {
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= appState.characters.length) return;

            // Save state for undo
            saveStateForUndo();

            // Swap characters
            const temp = appState.characters[index];
            appState.characters[index] = appState.characters[newIndex];
            appState.characters[newIndex] = temp;

            updateTopCharacters();
            renderCharacterList();
            saveToLocalStorage();
        }

        function editCharacterName(index) {
            const char = appState.characters[index];
            const newName = prompt(`Edit character name:`, char.name);

            if (!newName || newName.trim() === '') return; // User cancelled or empty
            if (newName === char.name) return; // No change

            // Check if new name already exists
            if (appState.characters.some(c => c.name === newName.trim())) {
                alert('A character with that name already exists.');
                return;
            }

            // Save state for undo
            saveStateForUndo();

            // Update the character name
            appState.characters[index].name = newName.trim();

            updateTopCharacters();
            renderCharacterList();
            saveToLocalStorage();
        }

        function deleteCharacter(index) {
            const char = appState.characters[index];

            // Prevent deleting "(Other)"
            if (char.name === '(Other)') {
                alert('Cannot delete the special "(Other)" category.');
                return;
            }

            const confirmDelete = confirm(`Delete character "${char.name}"?\n\nThis will remove it from the list but won't affect already-annotated lines.`);
            if (!confirmDelete) return;

            // Save state for undo
            saveStateForUndo();

            // Remove the character
            appState.characters.splice(index, 1);

            updateTopCharacters();
            renderCharacterList();
            saveToLocalStorage();
        }

        function sortCharactersByFrequency() {
            // Count how many characters have non-zero counts
            const withCounts = appState.characters.filter(c => c.count > 0 && c.name !== '(Other)').length;

            if (withCounts === 0) {
                alert('No characters have dialogue counts to sort by.\n\nCounts are based on pre-filled characters from the subtitle file.');
                return;
            }

            // Separate (Other) from the rest
            const otherIndex = appState.characters.findIndex(c => c.name === '(Other)');
            let other = null;
            if (otherIndex !== -1) {
                other = appState.characters.splice(otherIndex, 1)[0];
            }

            // Sort remaining characters by count (descending), then alphabetically for ties
            appState.characters.sort((a, b) => {
                if (b.count !== a.count) {
                    return b.count - a.count;
                }
                return a.name.localeCompare(b.name);
            });

            // Put (Other) back at the beginning
            if (other) {
                appState.characters.unshift(other);
            }

            updateTopCharacters();
            renderCharacterList();
            saveToLocalStorage();
        }

        function exportCharacterList() {
            const defaultName = appState.filename
                ? appState.filename.replace(/\.(srt|ass)$/i, '-characters.json')
                : 'character-list.json';

            const filename = prompt('Enter filename for character list:', defaultName);
            if (!filename) return; // User cancelled

            // Export only non-alias characters with their alias information
            const characterList = appState.characters
                .filter(c => !c.isAlias)
                .map(c => ({
                    name: c.name,
                    canonicalName: c.canonicalName || c.name,
                    aliases: c.aliases || []
                }));

            const blob = new Blob([JSON.stringify(characterList, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename.endsWith('.json') ? filename : filename + '.json';
            a.click();
            URL.revokeObjectURL(url);

            // Also save to localStorage as global list
            localStorage.setItem('global-character-list', JSON.stringify(characterList));
        }

        function importCharacterList(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);

                    if (!Array.isArray(imported)) {
                        alert('Invalid character list format');
                        return;
                    }

                    // Build alias-to-canonical mapping from imported list
                    const aliasMap = {};
                    imported.forEach(importedChar => {
                        if (importedChar.aliases && importedChar.aliases.length > 0) {
                            importedChar.aliases.forEach(alias => {
                                aliasMap[alias] = importedChar.canonicalName || importedChar.name;
                            });
                        }
                    });

                    // Update existing characters that match aliases to use canonical names
                    appState.characters.forEach(existingChar => {
                        if (aliasMap[existingChar.name]) {
                            const canonicalName = aliasMap[existingChar.name];
                            // Update subtitles to use canonical name
                            appState.subtitles.forEach(sub => {
                                if (sub.character === existingChar.name) {
                                    sub.character = canonicalName;
                                }
                            });
                            // Mark this character for removal (will be handled below)
                            existingChar._shouldRemove = true;
                        }
                    });

                    // Remove characters that were aliases
                    appState.characters = appState.characters.filter(c => !c._shouldRemove);

                    // Merge imported list with existing characters
                    imported.forEach(importedChar => {
                        const existing = appState.characters.find(c => c.name === importedChar.name);
                        if (!existing) {
                            // Add new character (count will be recalculated from subtitles)
                            const count = appState.subtitles.filter(s => s.character === importedChar.name).length;
                            appState.characters.push({
                                name: importedChar.name,
                                canonicalName: importedChar.canonicalName || importedChar.name,
                                aliases: importedChar.aliases || [],
                                count: count,
                                isAlias: false
                            });
                        } else {
                            // Update existing character with alias information
                            existing.canonicalName = importedChar.canonicalName || importedChar.name;
                            existing.aliases = importedChar.aliases || [];
                            // Recalculate count from subtitles
                            existing.count = appState.subtitles.filter(s => s.character === existing.name).length;
                        }
                    });

                    // Reorder to match imported list (put imported characters first, in order)
                    const reordered = [];
                    imported.forEach(importedChar => {
                        const char = appState.characters.find(c => c.name === importedChar.name);
                        if (char) {
                            reordered.push(char);
                        }
                    });
                    // Add any characters not in the imported list (and not aliases)
                    appState.characters.forEach(char => {
                        if (!reordered.includes(char) && !aliasMap[char.name]) {
                            reordered.push(char);
                        }
                    });
                    appState.characters = reordered;

                    updateTopCharacters();
                    renderCharacterList();
                    saveToLocalStorage();

                    alert('Character list imported successfully!');
                } catch (err) {
                    alert('Error importing character list: ' + err.message);
                }
            };
            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        function editCharacters() {
            document.getElementById('annotationWorkspace').style.display = 'none';
            document.getElementById('characterManagement').style.display = 'block';
            renderCharacterList();
        }

        function startAnnotating() {
            // Check if there's at least one non-alias character
            if (appState.characters.filter(c => !c.isAlias).length === 0) {
                alert('Please add at least one character before annotating');
                return;
            }

            // Reset filter when starting annotation (unless already in annotation mode)
            if (document.getElementById('annotationWorkspace').style.display === 'none') {
                currentFilter = 'all';
            }

            document.getElementById('characterManagement').style.display = 'none';
            document.getElementById('annotationWorkspace').style.display = 'block';

            renderAnnotationWorkspace();
        }

        function renderAnnotationWorkspace() {
            populateCharacterFilter();
            renderKeyboardHints();
            renderSubtitleList();
            updateProgress();
            // Highlight the first unannotated line for keyboard shortcuts
            scrollToNextUnannotated();
        }

        function populateCharacterFilter() {
            const filterSelect = document.getElementById('characterFilter');

            // Use currentFilter variable as source of truth
            const currentValue = currentFilter;

            // Clear existing character options (keep "All" and "Unannotated")
            while (filterSelect.options.length > 2) {
                filterSelect.remove(2);
            }

            // Add separator
            const separator = document.createElement('option');
            separator.disabled = true;
            separator.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
            filterSelect.appendChild(separator);

            // Add character options (only non-alias characters)
            const characters = appState.characters.filter(c => !c.isAlias && c.name !== '(Other)');
            characters.forEach(char => {
                const option = document.createElement('option');
                option.value = char.name;
                const count = appState.subtitles.filter(s => s.character === char.name).length;
                option.textContent = `${char.name} (${count} lines)`;
                filterSelect.appendChild(option);
            });

            // Add "(Other)" at the end
            const otherChar = appState.characters.find(c => c.name === '(Other)');
            if (otherChar) {
                const option = document.createElement('option');
                option.value = '(Other)';
                const count = appState.subtitles.filter(s => s.character === '(Other)').length;
                option.textContent = `(Other) (${count} lines)`;
                filterSelect.appendChild(option);
            }

            // Restore selection if it still exists
            if (currentValue && Array.from(filterSelect.options).some(opt => opt.value === currentValue)) {
                filterSelect.value = currentValue;
            } else {
                filterSelect.value = 'all';
                currentFilter = 'all';
            }
        }

        function handleFilterChange() {
            const filterSelect = document.getElementById('characterFilter');
            currentFilter = filterSelect.value;
            renderSubtitleList();
            updateFilterStats();
        }

        function updateFilterStats() {
            const statsEl = document.getElementById('filterStats');
            let filteredCount;

            if (currentFilter === 'all') {
                filteredCount = appState.subtitles.length;
                statsEl.textContent = `Showing all ${filteredCount} lines`;
            } else if (currentFilter === 'unannotated') {
                filteredCount = appState.subtitles.filter(s => !s.character).length;
                statsEl.textContent = `Showing ${filteredCount} unannotated lines`;
            } else {
                filteredCount = appState.subtitles.filter(s => s.character === currentFilter).length;
                statsEl.textContent = `Showing ${filteredCount} lines`;
            }
        }

        function renderKeyboardHints() {
            const container = document.getElementById('shortcutHints');
            const hints = appState.topCharacters.map((char, idx) =>
                `<div class="shortcut"><span class="key">${idx + 1}</span> ${char}</div>`
            );
            hints.push('<div class="shortcut"><span class="key">0</span> (Other)</div>');
            hints.push('<div class="shortcut"><span class="key">S</span> Jump to first unannotated</div>');
            hints.push('<div class="shortcut"><span class="key">J/K</span> Navigate up/down</div>');
            hints.push('<div class="shortcut"><span class="key">Ctrl+Z</span> Undo</div>');
            hints.push('<div class="shortcut"><span class="key">Ctrl+Y</span> Redo</div>');
            container.innerHTML = hints.join('');
        }

        function renderSubtitleList() {
            const container = document.getElementById('subtitleList');
            container.innerHTML = '';

            // Apply filter
            let filteredSubtitles = appState.subtitles;
            if (currentFilter === 'unannotated') {
                filteredSubtitles = appState.subtitles.filter(s => !s.character);
            } else if (currentFilter !== 'all') {
                filteredSubtitles = appState.subtitles.filter(s => s.character === currentFilter);
            }

            // Update filter stats
            updateFilterStats();

            // Only show non-alias characters in dropdown
            const enabledCharacters = appState.characters.filter(c => !c.isAlias);

            filteredSubtitles.forEach((sub) => {
                const idx = appState.subtitles.indexOf(sub); // Get original index
                const entry = document.createElement('div');
                entry.className = 'subtitle-entry';
                if (sub.character) {
                    entry.classList.add(sub.isPrefilled ? 'prefilled' : 'annotated');
                }
                entry.dataset.index = idx;

                const select = document.createElement('select');
                select.innerHTML = '<option value="">-- Select --</option>';
                enabledCharacters.forEach(char => {
                    const option = document.createElement('option');
                    option.value = char.name;
                    option.textContent = char.name;
                    if (sub.character === char.name) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
                select.addEventListener('change', (e) => assignCharacter(idx, e.target.value));

                entry.innerHTML = `
                    <div class="entry-index">#${sub.index + 1}</div>
                    <div class="entry-timestamp">${sub.timestamp}</div>
                    <div class="entry-text">${sub.text}</div>
                    <div class="entry-character"></div>
                    <div class="entry-status">${sub.character ? '‚úì' : ''}</div>
                `;

                entry.querySelector('.entry-character').appendChild(select);
                container.appendChild(entry);
            });

            // Add keyboard listener (remove first to prevent duplicates)
            document.removeEventListener('keydown', handleKeyPress);
            document.addEventListener('keydown', handleKeyPress);
        }

        function handleKeyPress(e) {
            // Only handle if not in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

            const key = e.key.toLowerCase();

            // Check for '0' key - always assign (Other)
            if (key === '0') {
                e.preventDefault();
                assignToActiveLine('(Other)');
                return;
            }

            // Check for number keys 1-9 - assign to active line
            if (key >= '1' && key <= '9') {
                e.preventDefault();
                const charIndex = parseInt(key) - 1;
                if (charIndex < appState.topCharacters.length) {
                    const character = appState.topCharacters[charIndex];
                    assignToActiveLine(character);
                }
                return;
            }

            // Check for 's' key (skip) - move to next unannotated line
            if (key === 's') {
                e.preventDefault();
                scrollToNextUnannotated();
                return;
            }

            // Check for j/k or arrow keys for navigation
            if (key === 'j' || key === 'arrowdown') {
                e.preventDefault();
                navigateLines(1);
                return;
            }
            if (key === 'k' || key === 'arrowup') {
                e.preventDefault();
                navigateLines(-1);
                return;
            }
        }

        function navigateLines(direction) {
            const currentActive = document.querySelector('.subtitle-entry.active');
            let currentIndex = currentActive ? parseInt(currentActive.dataset.index) : -1;

            const nextIndex = currentIndex + direction;
            if (nextIndex >= 0 && nextIndex < appState.subtitles.length) {
                document.querySelectorAll('.subtitle-entry').forEach(entry => {
                    entry.classList.remove('active');
                });

                const nextElement = document.querySelector(`[data-index="${nextIndex}"]`);
                if (nextElement) {
                    nextElement.classList.add('active');
                    nextElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }

        function assignToActiveLine(character) {
            // Find the currently active line (highlighted with orange border)
            const activeEntry = document.querySelector('.subtitle-entry.active');
            if (activeEntry) {
                const index = parseInt(activeEntry.dataset.index);
                assignCharacter(index, character);
                // Move to next unannotated line after assignment
                scrollToNextUnannotated();
            } else {
                // No active line - fall back to first unannotated
                assignToFirstUnannotated(character);
            }
        }

        function assignToFirstUnannotated(character) {
            const firstUnannotated = appState.subtitles.findIndex(s => !s.character);
            if (firstUnannotated !== -1) {
                assignCharacter(firstUnannotated, character);
                scrollToNextUnannotated();
            }
        }

        function scrollToNextUnannotated() {
            // Find the first unannotated line
            const firstUnannotated = appState.subtitles.findIndex(s => !s.character);

            // Update active highlighting
            document.querySelectorAll('.subtitle-entry').forEach(entry => {
                entry.classList.remove('active');
            });

            if (firstUnannotated !== -1) {
                const element = document.querySelector(`[data-index="${firstUnannotated}"]`);
                if (element) {
                    element.classList.add('active');
                    element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }

        function assignCharacter(index, character) {
            // Save state for undo
            saveStateForUndo();

            appState.subtitles[index].character = character || null;
            appState.subtitles[index].isPrefilled = false;

            saveToLocalStorage();
            updateProgress();
            populateCharacterFilter(); // Update filter counts

            // Update the visual representation
            const entry = document.querySelector(`[data-index="${index}"]`);
            if (entry) {
                entry.classList.remove('annotated', 'prefilled', 'active');
                if (character) {
                    entry.classList.add('annotated');
                }
                entry.querySelector('.entry-status').textContent = character ? '‚úì' : '';

                // Update the dropdown value
                const select = entry.querySelector('select');
                if (select) {
                    select.value = character || '';
                }
            }
        }

        function updateProgress() {
            const total = appState.subtitles.length;
            const annotated = appState.subtitles.filter(s => s.character).length;
            const percentage = total > 0 ? (annotated / total) * 100 : 0;

            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = percentage + '%';
            progressFill.textContent = `${annotated} / ${total} annotated`;

            const exportStats = document.getElementById('exportStats');
            exportStats.textContent = `${annotated} lines annotated, ${total - annotated} remaining`;
        }

        function saveToLocalStorage() {
            const key = `subtitle-annotation-${appState.filename}`;
            localStorage.setItem(key, JSON.stringify(appState));
        }

        function checkForSavedSession() {
            // Check if there are any saved sessions in localStorage
            const savedKeys = Object.keys(localStorage).filter(key => key.startsWith('subtitle-annotation-'));

            if (savedKeys.length > 0) {
                const message = `Found ${savedKeys.length} saved session(s). Would you like to see them?`;
                if (confirm(message)) {
                    const sessionList = savedKeys.map(key => {
                        const filename = key.replace('subtitle-annotation-', '');
                        return filename;
                    }).join('\n- ');

                    alert(`Saved sessions:\n- ${sessionList}\n\nLoad a file with the same name to restore your progress.`);
                }
            }
        }

        // Undo/Redo functionality
        function deepCopyState() {
            // Deep copy the appState for undo/redo
            return {
                filename: appState.filename,
                subtitles: appState.subtitles.map(sub => ({...sub})),
                characters: appState.characters.map(char => ({
                    ...char,
                    aliases: char.aliases ? [...char.aliases] : []
                })),
                topCharacters: [...appState.topCharacters]
            };
        }

        function saveStateForUndo() {
            // Save current state to undo stack
            undoStack.push(deepCopyState());

            // Limit stack size
            if (undoStack.length > MAX_UNDO_STATES) {
                undoStack.shift();
            }

            // Clear redo stack when new action is performed
            redoStack = [];
        }

        function performUndo() {
            if (undoStack.length === 0) {
                return false; // Nothing to undo
            }

            // Save current state to redo stack
            redoStack.push(deepCopyState());

            // Restore previous state
            const previousState = undoStack.pop();
            appState = previousState;

            // Refresh UI
            refreshCurrentView();
            saveToLocalStorage();

            return true;
        }

        function performRedo() {
            if (redoStack.length === 0) {
                return false; // Nothing to redo
            }

            // Save current state to undo stack
            undoStack.push(deepCopyState());

            // Restore redo state
            const redoState = redoStack.pop();
            appState = redoState;

            // Refresh UI
            refreshCurrentView();
            saveToLocalStorage();

            return true;
        }

        function refreshCurrentView() {
            // Determine which view is currently visible and refresh it
            const characterMgmt = document.getElementById('characterManagement');
            const annotationWs = document.getElementById('annotationWorkspace');

            if (characterMgmt.style.display !== 'none') {
                // Refresh character management view
                updateTopCharacters();
                renderCharacterList();
            } else if (annotationWs.style.display !== 'none') {
                // Refresh annotation workspace view
                updateTopCharacters();
                populateCharacterFilter();
                renderSubtitleList();
                updateProgress();
            }
        }

        // Setup global keyboard listener for undo/redo
        document.addEventListener('keydown', (e) => {
            // Check for Ctrl+Z (undo)
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                // Don't trigger if user is typing in an input field
                if (e.target.tagName === 'INPUT' && e.target.type === 'text') return;

                e.preventDefault();
                if (performUndo()) {
                    console.log('Undo performed');
                }
            }

            // Check for Ctrl+Y or Ctrl+Shift+Z (redo)
            if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
                // Don't trigger if user is typing in an input field
                if (e.target.tagName === 'INPUT' && e.target.type === 'text') return;

                e.preventDefault();
                if (performRedo()) {
                    console.log('Redo performed');
                }
            }
        });

        function updateFilenameDisplay() {
            const currentFileEl = document.getElementById('currentFile');
            const filenameEl = document.getElementById('filename');

            if (appState.filename) {
                filenameEl.textContent = appState.filename;
                currentFileEl.style.display = 'block';
            } else {
                currentFileEl.style.display = 'none';
            }
        }

        function showExportModal() {
            document.getElementById('exportModal').classList.add('show');
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('show');
        }

        function handleExport() {
            const format = document.querySelector('input[name="exportFormat"]:checked').value;
            if (format === 'json') {
                exportJSON();
            } else if (format === 'csv') {
                exportCSV();
            }
        }

        function exportJSON() {
            const exportType = document.querySelector('input[name="exportType"]:checked').value;

            let dataToExport = appState.subtitles;
            if (exportType === 'annotated') {
                dataToExport = appState.subtitles.filter(s => s.character);
            }

            const jsonData = dataToExport.map(sub => {
                // Use canonical name for export
                let characterName = sub.character || null;
                if (characterName) {
                    const charObj = appState.characters.find(c => c.name === characterName);
                    if (charObj && charObj.canonicalName) {
                        characterName = charObj.canonicalName;
                    }
                }

                return {
                    timestamp: sub.timestamp,
                    character: characterName,
                    dialogue: sub.text
                };
            });

            const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = appState.filename.replace(/\.(srt|ass)$/i, '-annotated.json');
            a.click();
            URL.revokeObjectURL(url);

            closeExportModal();
        }

        function exportCSV() {
            const exportType = document.querySelector('input[name="exportType"]:checked').value;

            let dataToExport = appState.subtitles;
            if (exportType === 'annotated') {
                dataToExport = appState.subtitles.filter(s => s.character);
            }

            // Build CSV with header row
            const csvRows = [];
            csvRows.push('timestamp,character,dialogue');

            // Add data rows
            dataToExport.forEach(sub => {
                // Use canonical name for export
                let characterName = sub.character || '';
                if (characterName) {
                    const charObj = appState.characters.find(c => c.name === characterName);
                    if (charObj && charObj.canonicalName) {
                        characterName = charObj.canonicalName;
                    }
                }

                const timestamp = escapeCSV(sub.timestamp);
                const character = escapeCSV(characterName);
                const dialogue = escapeCSV(sub.text);
                csvRows.push(`${timestamp},${character},${dialogue}`);
            });

            // Add UTF-8 BOM to ensure Excel properly detects encoding (especially on non-English locales)
            const BOM = '\uFEFF';
            const csvContent = BOM + csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = appState.filename.replace(/\.(srt|ass)$/i, '-annotated.csv');
            a.click();
            URL.revokeObjectURL(url);

            closeExportModal();
        }

        function escapeCSV(value) {
            if (value === null || value === undefined) {
                return '';
            }

            const stringValue = String(value);

            // If the value contains comma, quote, or newline, wrap in quotes and escape internal quotes
            if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                return '"' + stringValue.replace(/"/g, '""') + '"';
            }

            return stringValue;
        }

        function clearSession() {
            if (confirm('Are you sure you want to clear all annotations? This cannot be undone.')) {
                const key = `subtitle-annotation-${appState.filename}`;
                localStorage.removeItem(key);
                appState.subtitles.forEach(sub => {
                    if (!sub.isPrefilled) {
                        sub.character = null;
                    }
                });
                renderSubtitleList();
                updateProgress();
            }
        }

        function resetApp() {
            if (confirm('Are you sure you want to start over? Unsaved progress will be lost.')) {
                appState = {
                    filename: '',
                    subtitles: [],
                    characters: [],
                    topCharacters: []
                };

                // Clear undo/redo stacks
                undoStack = [];
                redoStack = [];

                updateFilenameDisplay();
                document.getElementById('uploadSection').style.display = 'block';
                document.getElementById('characterManagement').style.display = 'none';
                document.getElementById('annotationWorkspace').style.display = 'none';
                document.getElementById('fileInput').value = '';
            }
        }
    </script>
</body>
</html>
